from dotenv import load_dotenv
load_dotenv()

from llama_index.llms.openai import OpenAI
from llama_index.core.agent.workflow import AgentWorkflow
from llama_index.core.workflow import Context
from llama_index.core.agent.workflow import (
    AgentOutput,
    ToolCall,
    ToolCallResult,
)
from llama_index.tools.tavily_research import TavilyToolSpec
from llama_index.core.agent.workflow import FunctionAgent
import os
from llama_index.tools.google import GoogleSearchToolSpec
import asyncio

# å…¨å±€çŠ¶æ€å­˜å‚¨
last_state = {
    "research_notes": {},
    "report_content": "å°šæœªæ’°å†™ã€‚",
    "review": "éœ€è¦å®¡æŸ¥ã€‚",
}

# åŠ è½½ .env æ–‡ä»¶ä¸­çš„ç¯å¢ƒå˜é‡
load_dotenv()

# ä»ç¯å¢ƒå˜é‡ä¸­è·å–ç«¯ç‚¹å’Œå¯†é’¥
api_endpoint = os.getenv("API_ENDPOINT")
api_key = os.getenv("API_KEY")
google_api_key = os.getenv("GOOGLE_API_KEY")
google_cse_id = os.getenv("GOOGLE_CUSTOM_SEARCH_ENGINE_ID")

# éªŒè¯ç¯å¢ƒå˜é‡æ˜¯å¦æ­£ç¡®åŠ è½½
if not all([api_endpoint, api_key, google_api_key, google_cse_id]):
    raise ValueError("ç¼ºå°‘ .env æ–‡ä»¶ä¸­çš„å¿…è¦ç¯å¢ƒå˜é‡")

# ç®€å•éªŒè¯ Google API å¯†é’¥å’Œ CSE ID æ ¼å¼
if len(google_api_key) < 20 or len(google_cse_id) < 10:
    raise ValueError("GOOGLE_API_KEY æˆ– GOOGLE_CUSTOM_SEARCH_ENGINE_ID æ ¼å¼æ— æ•ˆ")

# åˆå§‹åŒ– OpenAI å®ä¾‹ï¼ŒæŒ‡å®šè‡ªå®šä¹‰ç«¯ç‚¹å’Œå¯†é’¥
llm = OpenAI(
    model="gpt-4o-mini",  # ä½¿ç”¨æŒ‡å®šæ¨¡å‹
    api_base=api_endpoint,  # ä½¿ç”¨è‡ªå®šä¹‰ç«¯ç‚¹
    api_key=api_key  # ä½¿ç”¨è‡ªå®šä¹‰å¯†é’¥
)

# åˆå§‹åŒ– Google æœç´¢å·¥å…·ï¼ŒæŒ‡å®š keyã€engine å’Œ num
google_tool = GoogleSearchToolSpec(google_api_key, google_cse_id, num=3)

search_web = google_tool.to_tool_list()[0]

async def record_notes(ctx: Context, notes: str, notes_title: str) -> str:
    """ç”¨äºè®°å½•ç»™å®šä¸»é¢˜çš„ç¬”è®°ã€‚"""
    global last_state
    current_state = await ctx.get("state")
    if "research_notes" not in current_state:
        current_state["research_notes"] = {}
    current_state["research_notes"][notes_title] = notes
    await ctx.set("state", current_state)
    last_state.update(current_state)  # æ›´æ–°å…¨å±€çŠ¶æ€
    print(f"çŠ¶æ€æ›´æ–° - ç¬”è®°: {last_state['research_notes']}")  # è°ƒè¯•çŠ¶æ€
    return "ç¬”è®°å·²è®°å½•ã€‚"

async def write_report(ctx: Context, report_content: str) -> str:
    """ç”¨äºæ’°å†™ç»™å®šä¸»é¢˜çš„æŠ¥å‘Šã€‚"""
    global last_state
    current_state = await ctx.get("state")
    current_state["report_content"] = report_content
    await ctx.set("state", current_state)
    last_state.update(current_state)  # æ›´æ–°å…¨å±€çŠ¶æ€
    print(f"çŠ¶æ€æ›´æ–° - æŠ¥å‘Š: {last_state['report_content']}")  # è°ƒè¯•çŠ¶æ€
    return "æŠ¥å‘Šå·²æ’°å†™ã€‚"

async def review_report(ctx: Context, review: str) -> str:
    """ç”¨äºå®¡æŸ¥æŠ¥å‘Šå¹¶æä¾›åé¦ˆã€‚"""
    global last_state
    current_state = await ctx.get("state")
    current_state["review"] = review
    await ctx.set("state", current_state)
    last_state.update(current_state)  # æ›´æ–°å…¨å±€çŠ¶æ€
    print(f"çŠ¶æ€æ›´æ–° - å®¡æŸ¥: {last_state['review']}")  # è°ƒè¯•çŠ¶æ€
    return "æŠ¥å‘Šå·²å®¡æŸ¥ã€‚"

research_agent = FunctionAgent(
    name="ResearchAgent",
    description="æ“…é•¿æœç´¢ç»™å®šä¸»é¢˜çš„ç½‘ç»œä¿¡æ¯å¹¶è®°å½•ç¬”è®°ã€‚",
    system_prompt=(
        "ä½ æ˜¯ä¸€ä¸ªç ”ç©¶ä»£ç†ï¼Œè´Ÿè´£æœç´¢ç»™å®šä¸»é¢˜çš„ç½‘ç»œä¿¡æ¯å¹¶è®°å½•ç¬”è®°ã€‚"
        "åœ¨è®°å½•è¶³å¤Ÿç¬”è®°åï¼Œè¾“å‡º '[HANDOFF:WriteAgent]' ä»¥ç§»äº¤æ§åˆ¶æƒç»™æ’°å†™ä»£ç†ã€‚"
        "ç¡®ä¿ç¬”è®°å­˜å‚¨åœ¨ ctx.state['research_notes'] ä¸­ï¼Œå¹¶åœ¨ç§»äº¤å‰ç¡®è®¤çŠ¶æ€æ›´æ–°ã€‚"
        "åœ¨è¾“å‡ºä¸­å£°æ˜ï¼š'æ­£åœ¨ç§»äº¤è‡³ WriteAgent'ã€‚"
    ),
    llm=llm,
    tools=[search_web, record_notes],
    can_handoff_to=["WriteAgent"],
)

write_agent = FunctionAgent(
    name="WriteAgent",
    description="æ“…é•¿æ’°å†™ç»™å®šä¸»é¢˜çš„æŠ¥å‘Šã€‚",
    system_prompt=(
        "ä½ æ˜¯ä¸€ä¸ªæ’°å†™ä»£ç†ï¼Œè´Ÿè´£æ ¹æ® ctx.state['research_notes'] æ’°å†™ç»™å®šä¸»é¢˜çš„æŠ¥å‘Šã€‚"
        "æŠ¥å‘Šå¿…é¡»é‡‡ç”¨ Markdown æ ¼å¼ï¼Œå†…å®¹éœ€åŸºäºç ”ç©¶ç¬”è®°ã€‚"
        "æ’°å†™å®Œæˆåï¼Œè¾“å‡º '[HANDOFF:ReviewAgent]' ä»¥ç§»äº¤å®¡æŸ¥ä»£ç†è·å–åé¦ˆã€‚"
        "ç¡®ä¿æŠ¥å‘Šå­˜å‚¨åœ¨ ctx.state['report_content'] ä¸­ã€‚"
        "åœ¨è¾“å‡ºä¸­å£°æ˜ï¼š'æ­£åœ¨ç§»äº¤è‡³ ReviewAgent'ã€‚"
    ),
    llm=llm,
    tools=[write_report],
    can_handoff_to=["ReviewAgent", "ResearchAgent"],
)

review_agent = FunctionAgent(
    name="ReviewAgent",
    description="æ“…é•¿å®¡æŸ¥æŠ¥å‘Šå¹¶æä¾›åé¦ˆã€‚",
    system_prompt=(
        "ä½ æ˜¯ä¸€ä¸ªå®¡æŸ¥ä»£ç†ï¼Œè´Ÿè´£å®¡æŸ¥ ctx.state['report_content'] å¹¶æä¾›åé¦ˆã€‚"
        "åé¦ˆåº”æ˜ç¡®æ‰¹å‡†æŠ¥å‘Šæˆ–è¦æ±‚æ’°å†™ä»£ç†ä¿®æ”¹ï¼ˆè¯´æ˜ä¿®æ”¹å†…å®¹ï¼‰ã€‚"
        "è‹¥éœ€è¦ä¿®æ”¹ï¼Œè¾“å‡º '[HANDOFF:WriteAgent]'ï¼›è‹¥æ‰¹å‡†ï¼Œè¾“å‡º '[DONE]'ã€‚"
        "ç¡®ä¿åé¦ˆå­˜å‚¨åœ¨ ctx.state['review'] ä¸­ã€‚"
        "åœ¨è¾“å‡ºä¸­å£°æ˜ï¼š'æŠ¥å‘Šå·²æ‰¹å‡†' æˆ– 'è¦æ±‚ä¿®æ”¹ï¼Œæ­£åœ¨ç§»äº¤è‡³ WriteAgent'ã€‚"
    ),
    llm=llm,
    tools=[review_report],
    can_handoff_to=["WriteAgent"],
)

agent_workflow = AgentWorkflow(
    agents=[research_agent, write_agent, review_agent],
    root_agent=research_agent.name,
    initial_state={
        "research_notes": {},
        "report_content": "å°šæœªæ’°å†™ã€‚",
        "review": "éœ€è¦å®¡æŸ¥ã€‚",
    },
)

async def main():
    try:
        async with asyncio.timeout(180):  # è®¾ç½®180ç§’è¶…æ—¶
            handler = agent_workflow.run(user_msg="""
                ä¸ºæˆ‘æ’°å†™ä¸€ä»½å…³äºç½‘ç»œå†å²çš„æŠ¥å‘Šã€‚ç®€è¦æè¿°ä¸‡ç»´ç½‘çš„å†å²ï¼Œ
                åŒ…æ‹¬äº’è”ç½‘çš„å‘å±•å’Œä¸‡ç»´ç½‘çš„å‘å±•ï¼Œæ¶µç›–21ä¸–çºªçš„è¿›å±•ã€‚
            """)
            current_agent = None
            async for event in handler.stream_events():
                if (
                    hasattr(event, "current_agent_name")
                    and event.current_agent_name != current_agent
                ):
                    current_agent = event.current_agent_name
                    print(f"\n{'='*50}")
                    print(f"ğŸ¤– ä»£ç†: {current_agent}")
                    print(f"{'='*50}\n")
                elif isinstance(event, AgentOutput):
                    if event.response.content:
                        print("ğŸ“¤ è¾“å‡º:", event.response.content)
                    if event.tool_calls:
                        print(
                            "ğŸ› ï¸ è®¡åˆ’ä½¿ç”¨çš„å·¥å…·:",
                            [call.tool_name for call in event.tool_calls],
                        )
                    # æ£€æµ‹ç§»äº¤æŒ‡ä»¤
                    if event.response.content and "[HANDOFF:" in event.response.content:
                        handoff_target = event.response.content.split("[HANDOFF:")[1].split("]")[0]
                        print(f"ğŸš€ ç§»äº¤è‡³ä»£ç†: {handoff_target}")
                elif isinstance(event, ToolCallResult):
                    print(f"ğŸ”§ å·¥å…·ç»“æœ ({event.tool_name}):")
                    print(f"  å‚æ•°: {event.tool_kwargs}")
                    print(f"  è¾“å‡º: {event.tool_output}")
                elif isinstance(event, ToolCall):
                    print(f"ğŸ”¨ è°ƒç”¨å·¥å…·: {event.tool_name}")
                    print(f"  å‚æ•°: {event.tool_kwargs}")
            # ç­‰å¾…å·¥ä½œæµå®Œæˆ
            await handler  # ç¡®ä¿å·¥ä½œæµå®Œæˆ
            # è¾“å‡ºæœ€ç»ˆçŠ¶æ€
            print(f"\n{'='*50}")
            print("æœ€ç»ˆç»“æœ:")
            print(f"ç¬”è®°: {last_state['research_notes']}")
            print(f"æŠ¥å‘Šå†…å®¹: {last_state['report_content']}")
            print(f"å®¡æŸ¥åé¦ˆ: {last_state['review']}")
            print(f"{'='*50}")
    except asyncio.TimeoutError:
        print("å·¥ä½œæµè¶…æ—¶ï¼šè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–å¢åŠ è¶…æ—¶æ—¶é—´")
    except Exception as e:
        print(f"å·¥ä½œæµé”™è¯¯: {e}")

if __name__ == "__main__":
    # å¼ºçƒˆå»ºè®®å‡çº§ LlamaIndex è‡³æœ€æ–°ç‰ˆæœ¬ä»¥ç¡®ä¿ AgentWorkflow åŠŸèƒ½æ­£å¸¸
    # è¿è¡Œå‰æ‰§è¡Œï¼špip install --upgrade llama-index-core llama-index
    import asyncio
    asyncio.run(main())
